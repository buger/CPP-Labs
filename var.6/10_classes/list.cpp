#include <stdlib.h>
#include <iostream>
#include <iomanip>
#include "list.h"

List::List(int n)    //конструктор инициализирует список из n элементов по принципу "очередь"
{
    NodePtr current; // указатель на текущий элемент

    // Обнуляем начальный элемент
    head = NULL;
    
    // Формируем стек из n элементов
    for (int i = 0; i<n; i++)
    { 
        // Если head равно NULL, значит наш стэк еще пуст, и нам надо созать первый элемент
        if (head == NULL)
        { 
            // Создаем новый элемент типа Node, который будет первым в стэке
            head = new Node;                        
            // Заполняем значение элемента случайными числами от -5 до 5
	    head->data = random(10) - 5;            

            // Устанавливаем значение link в NULL, так как это первый элемент нашего стэка
	    head->next = NULL;
        }
	else  
        {   
            // Создаем новый элемент типа Node
            current = new Node;            
            current->data = random(10) - 5;

            // Для нового элемента, следующим будет последний созданный, который постоянно находится в head
	    current->next = head;
            // Теперь первым элементом в стэке должен стать current
	    head = current;
        }
    }    
}

List::List(List& list_for_copy)
{
    // используется для перемещения по списку 
    // будет являться ссылкой на текущий элемент копируемого списка
    NodePtr iterator;

    NodePtr current; // указатель на текущий элемент
    NodePtr new_element; // указатель на текущий элемент
    
    NodePtr tail; // указатель на конец очереди


    // Обнуляем начальный элемент
    head = NULL;

    // Для того что бы скопировать список, мы должны пройтись циклом по всем его элементам    

    // Устанавливаем в начало копируемого списка
    iterator = list_for_copy.head;

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(iterator != NULL)
    {   
        // Если head равно NULL, значит наш стэк еще пуст, и нам надо созать первый элемент
        if (head == NULL)
        { 
            // Создаем новый элемент типа Node, который будет первым в стэке
            head = new Node;                        
            // Устанавливаем значение копируемого элемента
	    head->data = iterator->data;

            // Устанавливаем значение link в NULL, так как это первый элемент нашего стэка
            head->next = NULL;

            // Так как это первый элемент, то он является и концом
            tail = head;
        }
	else  
        {   
            // Создаем новый элемент типа Node
            current = new Node;            
            // Устанавливаем значение копируемого элемента
            current->data = iterator->data;
                        
	    /*
                Если мы будем копировать как стэк, то получим инвертированный список:
                  дан список который хотим скопировать: 1 -> 2 -> 3 -> 4 

                  Так как принципом стэка являетсяЖ первый вошел, первый вышел,
                  то при последовательном копировании списка мы получим:                  
                  
                  4 -> 3 -> 2 -> 1, ведь головой у копируемого списка была 1
                  Пример:
                  1 итерация:

                      1 
                      ^
                    head 

                  2 итерация:
                      2  ->  1
                      ^         
                    head    

                Для того что бы это не случилось нужно копироват его как очередь: Первым вошел, первым вышел
                  Для этого мы всегда храним наш головной элемент в head
                  и вводим понятие конца очереди tail, который всегда будет указывать на конец очереди:
                  1 итерация:

                      1  ->  2 
                      ^      ^
                    head    tail
                  
                  2 итерация:

                      1  ->  2  ->  3
                      ^             ^
                    head           tail
            */

            tail->next = current;
            // Теперь последним элементом в стэке должен стать current
	    tail = current;
        }
        
        // Переходим к следующему элементу копируемого списка
        iterator = iterator->next;
    }
}


void List::invert()
{
    // используется для перемещения по списку 
    // будет являться ссылкой на текущий элемент копируемого списка
    NodePtr iterator;

    NodePtr current; // указатель на текущий элемент
    NodePtr new_element; // указатель на текущий элемент
    NodePtr new_list_head;


    // Обнуляем начальный элемент
    new_list_head = NULL;

    // Для того что бы скопировать список, мы должны пройтись циклом по всем его элементам    

    // Устанавливаем в начало списка
    iterator = head;

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(iterator != NULL)
    {   
        // Если head равно NULL, значит наш стэк еще пуст, и нам надо созать первый элемент
        if (new_list_head == NULL)
        { 
            // Создаем новый элемент типа Node, который будет первым в стэке
            new_list_head = new Node;                        
            // Устанавливаем значение копируемого элемента
	    new_list_head->data = iterator->data;

            // Устанавливаем значение link в NULL, так как это первый элемент нашего стэка
	    new_list_head->next = NULL;
        }
	else  
        {   
            // Создаем новый элемент типа Node
            current = new Node;            
            // Устанавливаем значение копируемого элемента
            current->data = iterator->data;

            // Для нового элемента, следующим будет последний созданный, который постоянно находится в head
	    current->next = new_list_head;
            // Теперь первым элементом в стэке должен стать current
	    new_list_head = current;
        }
        
        // Переходим к следующему элементу копируемого списка
        iterator = iterator->next;
    }
    
    head = new_list_head;
}

// Поиск подсписка search_list
void List::search(List& search_list)
{
    cout << endl;
    cout << "Поиск списка: " << endl;
    search_list.print();
    cout << "В списке: " << endl;
    print();
    cout << endl;

    // Счетчик и метка найденного места, для того что бы вывести где найдено
    int counter = 0, current = 0;

    // Количество вхождений искомого списка
    int founded = 0;

    // используется для перемещения по нашему списку
    NodePtr iterator;
    
    NodePtr current_search; // указатель на текущий элемент, который ищется
    
    //Начинаем искать с первого элемента списка
    current_search = search_list.head;
    
    iterator = head;

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(iterator != NULL){
        // Если мы нашли первый элемент искомого списка, то перейдем к поиску следующего элемента
        if(iterator->data == current_search->data)            
        {               
            //Ичем следующий элемент
            current_search = current_search->next;

            // Если NULL значит мы дошли до конца списка, и он найден
            if(current_search == NULL){
                // +2 потому что, +1 берется так как мы считаем от 0, и еще +1 берется от того что current находится на предыдущем элементе
                cout << "Найдено соответствие начиная с " << current+2 << " элемента" << endl;

                founded++;
                
                // Ищем еще вхождения, если их несколько
                current = counter;
                current_search = search_list.head;
            }
        }
        else
        {
            // Так как ничего не найдено, то отправной точкой назначем текущий момент
            current = counter;

            //Если поиск какого либо элемента завершился неудачей, снова начинаем искать начиная с головного
            current_search = search_list.head;            
        }
        
        iterator = iterator->next;

        counter++;
    }

    cout << "Найдено совпадений: " << founded << endl; 
}

// Вывод списка
void List::print()
{
    NodePtr current; // Указатель на текущий элемент

    // Установим в начало
    current = head;

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(current != NULL)
    { 
        // Вывод значения текущего элемента
        // setw делается для красивого вывода
        cout << setw(5) << current->data;

        // Переходим к следующему элементу
        current = current->next;
    }
    
    // перейдем на следующую строку
    cout <<endl;    
}

// Деструктор - выполняется перед удалением объекта
// Перед удалением, необходимо отчистить память которую мы заняли
List::~ List()
{
    NodePtr current;// Ссылка на текущий элемент

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(head != NULL)
    {         
        current = head;

        // Переходим к следующему элементу
        head = head->next;
        
        // Очищаем память, занимаемую current
        delete current;
    }
}

