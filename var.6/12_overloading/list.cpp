#include <stdlib.h>
#include <iostream>
#include <iomanip>
#include "list.h"

List::List(int n)    //конструктор инициализирует список из n элементов по принципу "очередь"
{
    NodePtr current; // указатель на текущий элемент

    // Обнуляем начальный элемент
    head = NULL;
    
    // Формируем стек из n элементов
    for (int i = 0; i<n; i++)
    { 
        // Если head равно NULL, значит наш стэк еще пуст, и нам надо созать первый элемент
        if (head == NULL)
        { 
            // Создаем новый элемент типа Node, который будет первым в стэке
            head = new Node;                        
            // Заполняем значение элемента случайными числами от -5 до 5
	    head->data = rand()%10 - 5;            

            // Устанавливаем значение link в NULL, так как это первый элемент нашего стэка
	    head->next = NULL;
        }
	else  
        {   
            // Создаем новый элемент типа Node
            current = new Node;            
            current->data = rand()%10 - 5;

            // Для нового элемента, следующим будет последний созданный, который постоянно находится в head
	    current->next = head;
            // Теперь первым элементом в стэке должен стать current
	    head = current;
        }
    }    
}

List::List(List& list_for_copy)
{
    // используется для перемещения по списку 
    // будет являться ссылкой на текущий элемент копируемого списка
    NodePtr iterator;

    NodePtr current; // указатель на текущий элемент
    NodePtr new_element; // указатель на текущий элемент
    
    NodePtr tail; // указатель на конец очереди


    // Обнуляем начальный элемент
    head = NULL;

    // Для того что бы скопировать список, мы должны пройтись циклом по всем его элементам    

    // Устанавливаем в начало копируемого списка
    iterator = list_for_copy.head;

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(iterator != NULL)
    {   
        // Если head равно NULL, значит наш стэк еще пуст, и нам надо созать первый элемент
        if (head == NULL)
        { 
            // Создаем новый элемент типа Node, который будет первым в стэке
            head = new Node;                        
            // Устанавливаем значение копируемого элемента
	    head->data = iterator->data;

            // Устанавливаем значение link в NULL, так как это первый элемент нашего стэка
            head->next = NULL;

            // Так как это первый элемент, то он является и концом
            tail = head;
        }
	else  
        {   
            // Создаем новый элемент типа Node
            current = new Node;            
            // Устанавливаем значение копируемого элемента
            current->data = iterator->data;
                        
	    /*
                Если мы будем копировать как стэк, то получим инвертированный список:
                  дан список который хотим скопировать: 1 -> 2 -> 3 -> 4 

                  Так как принципом стэка являетсяЖ первый вошел, первый вышел,
                  то при последовательном копировании списка мы получим:                  
                  
                  4 -> 3 -> 2 -> 1, ведь головой у копируемого списка была 1
                  Пример:
                  1 итерация:

                      1 
                      ^
                    head 

                  2 итерация:
                      2  ->  1
                      ^         
                    head    

                Для того что бы это не случилось нужно копироват его как очередь: Первым вошел, первым вышел
                  Для этого мы всегда храним наш головной элемент в head
                  и вводим понятие конца очереди tail, который всегда будет указывать на конец очереди:
                  1 итерация:

                      1  ->  2 
                      ^      ^
                    head    tail
                  
                  2 итерация:

                      1  ->  2  ->  3
                      ^             ^
                    head           tail
            */

            tail->next = current;
            // Теперь последним элементом в стэке должен стать current
	    tail = current;
        }
        
        // Переходим к следующему элементу копируемого списка
        iterator = iterator->next;
    }
}

// Вывод списка
void List::print()
{
    NodePtr current; // Указатель на текущий элемент

    // Установим в начало
    current = head;

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(current != NULL)
    { 
        // Вывод значения текущего элемента
        // setw делается для красивого вывода
        cout << setw(5) << current->data;

        // Переходим к следующему элементу
        current = current->next;
    }
    
    cout << endl;    
}

 
/* 
  & формирование нового списка из двух списков так, 
  что каждый элемент информационного поля нового списка удовлетворяет условию: с = (а < b ) ? a : b

  Операция очень похоже на конструктор с копированием другого списка
*/

List& List::operator & (List& list)
{
    int calculated_data; // Используется для вычисления заданного условия

    // используется для перемещения по списку 
    // 2 так как нам нужно проходится по двум спискам
    NodePtr iterator, iterator_ext;

    NodePtr new_list_head; // указатель на текущий элемент

    NodePtr current; // указатель на текущий элемент
    NodePtr new_element; // указатель на текущий элемент
    
    NodePtr tail; // указатель на конец очереди

    // Обнуляем начальный элемент
    new_list_head = NULL;

    // Устанавливаем в начало списка
    iterator = head;
    iterator_ext = list.head;

    // Делаем цикл, пока не дойдем до последнего элемента любого из двух списков, у которого next NULL
    while(iterator != NULL && iterator_ext != NULL)
    {   
        // Если выполняется условые в скобках, выбираем первое значение, иначе второе
        //   с = (а < b ) ? a : b 
        calculated_data = (iterator->data < iterator_ext->data) ? iterator->data : iterator_ext-> data;

        // Если head равно NULL, значит наш стэк еще пуст, и нам надо созать первый элемент
        if (new_list_head == NULL)
        { 
            // Создаем новый элемент типа Node, который будет первым в стэке
            new_list_head = new Node;                        
            // Устанавливаем значение копируемого элемента
	    new_list_head->data = calculated_data;

            // Устанавливаем значение link в NULL, так как это первый элемент нашего стэка
            new_list_head->next = NULL;

            // Так как это первый элемент, то он является и концом
            tail = new_list_head;
        }
	else  
        {   
            // Создаем новый элемент типа Node
            current = new Node;            
            // Устанавливаем значение копируемого элемента
            current->data = calculated_data;
                        
            tail->next = current;
            // Теперь последним элементом в стэке должен стать current
	    tail = current;
        }
        
        // Переходим к следующему элементу копируемого списка
        iterator = iterator->next;
        iterator_ext = iterator_ext->next;
    }

    List* new_list = new List(0);
    new_list->head = new_list_head;

    return *new_list;
}

// Удаление элемента из списка, по индексу
void List::exclude(int index){
    //Счетчик элементов
    int counter = 0;

    NodePtr iterator; // Используется для хождению по списку
    NodePtr previous; // Хранит в себе предыдущий элемент

    // Устанавливаем начальные значения
    iterator = head;
    previous = NULL;

    while(iterator != NULL)        
    {   
        if(counter == index){            
            // Если дошли до нужного элемента, то вырежем его из списка
            //    1    ->   2   ->   3
            //    ^         ^        ^
            // previous  iterator   next
            // Хотим вырезать iterator
            //    1    ->   3
            //    ^         ^
            // previous    next

            previous->next = iterator->next;

            // Освобождаем память
            delete iterator;
            
            // Выходим из функции
            return;
        }

        counter++;

        // Текущий элемент становится предыдущим
        previous = iterator;
        // Переходим к следующему элементу
        iterator = iterator->next;        
    }
}

// Деструктор - выполняется перед удалением объекта
// Перед удалением, необходимо отчистить память которую мы заняли
List::~ List()
{
    NodePtr current;// Ссылка на текущий элемент

    // Делаем цикл, пока не дойдем до последнего элемента, у которого next NULL
    while(head != NULL)
    {         
        current = head;

        // Переходим к следующему элементу
        head = head->next;
        
        // Очищаем память, занимаемую current
        delete current;
    }
}

